// ��������ħ : 2024.11.5
// win32 Visual C 2010 �̻������Ͻ� �߰�
// ���α׷� ���� ù �ٿ� �߰��� ��
#define _CRT_SECURE_NO_WARNINGS
//-----------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <ctype.h>

/* for oracle */
#include <sqlda.h>
#include <sqlca.h>
#include <sqlcpr.h>


// win32 Visual C 2010 �̻������Ͻ� �߰�
#define getch() _getch()
//-----------------------------------------

/*---------------  ȭ�� Ŀ�� ��ġ ���� ----------------------*/
#include < windows.h >
void gotoxy(int x, int y) ;
void getxy(int *x, int *y) ;
void clrscr(void) ;
/*-----------------------------------------------------------*/
void print_screen(char fname[]);
void db_connect();
void select_tuple();
void insert_tuple();
void delete_tuple();
void update_tuple();
void sql_error();

int Error_flag = 0;
void main()
{
    char c = 0;

    _putenv("NLS_LANG=American_America.KO16KSC5601");  //�ѱۻ��� �ʿ���

   /* Register sql_error() as the error handler. */
    EXEC SQL WHENEVER SQLERROR DO sql_error("\7�����߻�:");

    db_connect();

    while( c != '5') {  
        // ���� ȭ�� ���
        clrscr();

        print_screen("scr_main.txt") ;
        gotoxy(49,15);

        
        c = getchar() ;
        while (getchar() != '\n');  // ù���� �� ������ �Է� ����

        switch(c){
            case '1' : select_tuple();
                         break;
            case '2' : insert_tuple();
                         break;
            case '3' : delete_tuple();
                         break;
            case '4' : update_tuple();
                         break;
            default : break ;
	
        }		
    }
 	
    clrscr();
    EXEC SQL COMMIT WORK RELEASE ;
}

void db_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR uid[80];
	VARCHAR pwd[20];
    EXEC SQL END DECLARE SECTION;

    strcpy(uid.arr,"a20203221@//sedb2.deu.ac.kr:1521/orcl");
    uid.len =  strlen(uid.arr);
    strcpy(pwd.arr,"20203221");
    pwd.len = strlen(pwd.arr);

    Error_flag = 0 ;  

   // �Ʒ� ���� ���� �߿� ������ �߻��ϸ� error ó�� ��ƾ���� ��. Error_flag=1�� �ٲ� 
    EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;

    // connection�� ������������� ó���κ�
    if ( Error_flag ==1 ){
        //printf("Connect error: %s", sqlca.sqlerrm.sqlerrmc);
        exit(-1);
    }
}


#define PAGE_NUM 5
void select_tuple()
{
/* --------------------------------------------------------------------------
   Retrieve the current maximum employee number
-------------------------------------------------------------------------- */
EXEC SQL BEGIN DECLARE SECTION;
   varchar v_empno[100];
   varchar v_ename[100];
   varchar v_job[100];

   char sqlstmt[1000];
EXEC SQL END DECLARE SECTION;

   char no_temp[20];
   char name_temp[20];

   int x, y, count=0, i ;

   /* ����� �Է� */
   clrscr();

   print_screen("scr_select.txt");

   gotoxy(22,5);
   gets(no_temp); 
   
   gotoxy(57,5);
   gets(name_temp);
      
   /* �����ų SQL ����*/
   sprintf(sqlstmt,"SELECT empno, ename, job FROM emp where to_char(empno) LIKE '%%%s%%' and ename LIKE '%%%s%%'  ",
                    no_temp, name_temp); 

   /* select ������ ����� �����Ǿ� �ִ��� ȭ�鿡 �� */
   //printf("sqlstmt:%s\n", sqlstmt);

   EXEC SQL PREPARE S FROM :sqlstmt ;

   /* 1. cursor declare */
   EXEC SQL DECLARE c_cursor CURSOR FOR S ; 

   /* 2. cursor open */
   EXEC SQL OPEN c_cursor ; 

   x = 14;
   y = 10 ;

   // EXEC SQL WHENEVER NOT FOUND DO break ;  ������ �̷��� �ؾ� �ϴµ� ���� ������ �Ʒ��� ���� �����
   while(1)
    {
        /* 3. tuple fetch */
        EXEC SQL FETCH c_cursor INTO :v_empno, :v_ename, :v_job;
       
        if(sqlca.sqlcode == 1403) {  // ���̻� ������ ������ ���� ���
            break;
        }
        v_empno.arr[v_empno.len] = '\0' ;
        v_ename.arr[v_ename.len] = '\0';
        v_job.arr[v_job.len] = '\0';

        gotoxy(x,y);
        printf(" | %-4s      |    %-10s  |    %-10s |", v_empno.arr, v_ename.arr , v_job.arr);
        y++;
        count++;
        if( count == PAGE_NUM){
            printf("\n\n                                  hit any key for next\n");
            count = 0;
            getch();

            gotoxy(0,10); //���� ȭ�� �κ� Ŭ����
            for(i= 0; i < PAGE_NUM; i++){
                printf("                                                                                               \n");
            }
            y = 10 ;
        }
    }
    printf("\n");	
    printf("                          match tuple no : %d\n", sqlca.sqlerrd[2]);

    /* 4. close the cursor. */
    EXEC SQL CLOSE c_cursor;

    getch();   // �ƹ�Ű�� ġ����. 

}
/*------------ insert -------------*/
void insert_tuple()
{
EXEC SQL BEGIN DECLARE SECTION;

    char sqlstmt[1000];

EXEC SQL END DECLARE SECTION;

    char v_empno[5];
    char v_ename[17];
    char v_job[16];

    int x, y ;

   clrscr();
   print_screen("scr_insert.txt");

   /* ������ �Է� */
    x = 40;
    y = 6 ;

   /* �����ȣ �Է� */
    gotoxy(x,y)  ; 
    gets(v_empno );
    
   /* ��� �̸� �Է� */
    y = y + 2 ;
    gotoxy(x,y)  ;
    gets(v_ename);

   /* ���� �Է� */
    y = y + 2 ;
    gotoxy(x,y) ;
    gets(v_job);
	
    sprintf(sqlstmt,"insert into emp(empno, ename, job) values ( %s, '%s', '%s')" ,v_empno, v_ename, v_job);

    // printf("sqlstmt:%s\n", sqlstmt);

   /* insert �� ���� */
    Error_flag = 0 ;

   // �Ʒ� ���� ���� �߿� ������ �߻��ϸ� error ó�� ��ƾ���� ��. Error_flag=1�� �ٲ� 
    EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;

    if( Error_flag == 0 ) {  // ���������� ���� �Ǵ� ���
        printf("\n");	
        printf(" ���������� �߰��Ǿ����ϴ�.  �ƹ�Ű�� ġ���� \n" ) ;
        EXEC SQL COMMIT WORK ;
        getch();
    }
    else {
        printf("\n");	
        printf(" Ʃ���� �߰����� �ʾҽ��ϴ�. �ƹ�Ű�� ġ���� \n" ) ;
        EXEC SQL ROLLBACK WORK ;
        getch();
    }
}

void update_tuple()
{
EXEC SQL BEGIN DECLARE SECTION;
    varchar v_empno[100];
    varchar v_ename[100];
    varchar v_job[16];

    char sqlstmt[1000];
EXEC SQL END DECLARE SECTION;

    char findno[100] ;
    char no[100] ;
    char name[100];
    char job[100];

    char  flag = 'n' ;
    int x, y ;
int i;
//----------------------------------------

   clrscr();
   print_screen("scr_update.txt");

    x = 40;
    y = 6 ;

    gotoxy(x,y)  ; 
    gets(findno) ;

/*------  ������ ������ ���� ã�Ƽ� ����ڿ��� ������ ----------------*/

    sprintf(sqlstmt,"SELECT empno, ename, job  FROM emp where empno = %s", findno) ;

    //printf("stmt:%s\n", sqlstmt);

    EXEC SQL PREPARE S FROM :sqlstmt ;

    EXEC SQL DECLARE u_cursor CURSOR FOR S ; 

    EXEC SQL OPEN u_cursor ; 

    while(1)
    {
        EXEC SQL FETCH u_cursor INTO :v_empno, :v_ename, :v_job ;

        if(sqlca.sqlcode == 1403) {  // ���̻� ������ ������ ���� ���
            break;
        }

        v_empno.arr[v_empno.len] = '\0';
        v_ename.arr[v_ename.len] = '\0';
        v_job.arr[v_job.len] = '\0';

        printf("\n");
        printf("                            �����ȣ:%s    ����̸�:%s   ����:%s \n", v_empno.arr, v_ename.arr, v_job.arr );
    }
    EXEC SQL CLOSE u_cursor; 

    /*  ������ ������ �ϳ��� ���� ���� �޽��� ��� �� ���ư��� �� */
    if ( sqlca.sqlerrd[2] == 0 ) {
        printf("�˻��� ������ �����ϴ�!!!  �ƹ�Ű�� ġ����");
        getch();
        return ;
    }

    //---------- update ó�� --------------
 /* ���� ������ �Է� */
    x = 40;
    y = 12 ;

   /* �����ȣ �Է� */
    gotoxy(x,y)  ; 
    gets(no);
    if( no[0] == '\0' ){
        strcpy(no, v_empno.arr);
   }
   /* ��� �̸� �Է� */
    y = y + 2 ;
    gotoxy(x,y)  ;
    gets(name);
    if( name[0] == '\0' ){
        strcpy(name, v_ename.arr);
   }
   /* ���� �Է� */
    y = y + 2 ;
    gotoxy(x,y) ;
    gets(job);
    if( job[0] == '\0' ){
        strcpy(job, v_job.arr);
    }
    sprintf(sqlstmt,"update emp set empno = %s, ename= '%s', job = '%s' where empno = %s ", no, name, job, findno);
    //printf("stmt:%s\n", sqlstmt);
    
     /* update�� ���� */
    Error_flag = 0 ;

   // �Ʒ� ���� ���� �߿� ������ �߻��ϸ� error ó�� ��ƾ���� ��. Error_flag=1�� �ٲ� 
    EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;

    if( Error_flag == 0 ) {  // ���������� ���� �Ǵ� ���
        printf("\n");	
        printf(" �����Ǿ����ϴ�. �ƹ�Ű�� ġ���� \n" ) ;
        EXEC SQL COMMIT WORK ;
        getch();
    }
    else {
        printf("\n");	
        printf(" �������� �ʾҽ��ϴ�. �ƹ�Ű�� ġ���� \n" ) ;
        EXEC SQL ROLLBACK WORK ;
        getch();
    }
   //EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;

  // EXEC SQL COMMIT WORK ; 

}
void delete_tuple()
{

EXEC SQL BEGIN DECLARE SECTION;
    varchar v_res_pt[100];
    varchar v_res_dept_date[100];
 
    char sqlstmt[1000];
EXEC SQL END DECLARE SECTION;

    char  no[100] ;
    char  flag = 'n' ;
    int x, y ;
int i;
//----------------------------------------

   clrscr();
   print_screen("scr_delete.txt");

    x = 40;
    y = 6 ;

    gotoxy(x,y)  ; 
    gets(no) ;

/*------ ������ ������ ���� ã�Ƽ� ����ڿ��� ������ ----------------*/

    sprintf(sqlstmt, "SELECT res_pt, TO_CHAR(res_dept_date, 'YYYY-MM-DD') FROM reservation WHERE res_no = %s", no);

    //printf("stmt:%s\n", sqlstmt);

    EXEC SQL PREPARE S FROM :sqlstmt ;

    EXEC SQL DECLARE d_cursor CURSOR FOR S ; 

    EXEC SQL OPEN d_cursor ; 

    while(1)
    {
        EXEC SQL FETCH d_cursor INTO :v_res_pt, :v_res_dept_date ;

        if(sqlca.sqlcode == 1403) {  // ���̻� ������ ������ ���� ���
            break;
        }

        v_res_pt.arr[v_res_pt.len] = '\0';
        v_res_dept_date.arr[v_res_dept_date.len] = '\0';
        printf("\n\n");
        printf("                                ȯ�ڼ���:%s    ���೯¥:%s \n", v_res_pt.arr, v_res_dept_date.arr);
    }
    EXEC SQL CLOSE d_cursor; 

    /*  ������ ������ �ϳ��� ���� ���� �޽��� ��� �� ���ư��� �� */
    if ( sqlca.sqlerrd[2] == 0 ) {
        printf("�˻��� ������ �����ϴ�!!!  �ƹ�Ű�� ġ����");
        getch();
        return ;
    }

    // ���� ó�� �κ�
    printf("���� ���õ��� �����Ͻðڽ��ϱ�? (y/n) :");   

    flag = (char *)getchar() ;
    while (getchar() != '\n');  // ù���� �� ������ �Է� ����

    if( flag == 'y' || flag =='Y' ){
        sprintf(sqlstmt,"delete from reservation where res_no = %s ", no);
        //printf("stmt:%s\n", sqlstmt);
        // �Ʒ� ���� ���� �߿� ������ �߻��ϸ� error ó�� ��ƾ���� ��. Error_flag=1�� �ٲ� 
        Error_flag = 0 ;
        EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;

        if( Error_flag == 0 ) {  // ���������� ���� �Ǵ� ���
            printf("\n");	
            printf(" ���������� �����Ǿ����ϴ�.  �ƹ�Ű�� ġ���� \n" ) ;
            EXEC SQL COMMIT WORK ;
            getch();
        }
        else {   //Error_falg == 1. ������ �߻��� ���
            printf("\n");	
            printf(" Ʃ���� �������� �ʾҽ��ϴ�. �ƹ�Ű�� ġ���� \n" ) ;
            EXEC SQL ROLLBACK WORK ;
            getch();
        }
    }
    else {    // ���� ���
        printf("\n");	
        printf("���� ���\n");
        printf("���θ޴��� ���� : �ƹ�Ű�� ġ����. ");
        getch();
    }

}
//==================================================

void print_screen(char fname[])
{
    FILE *fp;
    char line[100];

    if ( (fp = fopen(fname,"r"))  == NULL ){
        printf("file open error\n");
        getch();
        exit(-1);
    }
    while(1) {
        if( fgets(line, 99, fp) == NULL){
            break;
        }
        printf("%s", line);
    }

    fclose(fp);
}

/* --------------------------------------------------------------------------
int sql_error()

   errrpt prints the ORACLE error msg and number.
-------------------------------------------------------------------------- */
void sql_error(char *msg)
{
    char err_msg[128];
    size_t buf_len, msg_len;
    int x, y ;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    getxy(&x, &y);  // ���� Ŀ�� ��ġ ����

    Error_flag = 1;    //������ �߻����� ������

    gotoxy(1,22) ;   //������ �ٷ� �̵�

    printf("%s", msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &buf_len, &msg_len);
    printf("%.*s\n", msg_len, err_msg);

    gotoxy(x, y) ;   // ������ �ξ��� ���� Ŀ�� ��ġ�� �̵�
    //getch();
}
/*---------------  ȭ�� Ŀ�� ���� �Լ� --------------------*/
#define STD_HANDLE GetStdHandle(STD_OUTPUT_HANDLE)

void gotoxy(int x, int y)
{
    COORD Cur= {(SHORT)x, (SHORT) y};

    SetConsoleCursorPosition(STD_HANDLE, Cur);
}

void getxy(int *x, int *y)
{
    CONSOLE_SCREEN_BUFFER_INFO Buf ;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &Buf);
    *x = (int)Buf.dwCursorPosition.X ;
    *y = (int)Buf.dwCursorPosition.Y ;
 
}

void clrscr(void)
{
    COORD Cur= {0, 0};
    unsigned long dwLen;

//    FillConsoleOutputCharacter(STD_HANDLE, ' ', 80*25, Cur, &dwLen);
    FillConsoleOutputCharacter(STD_HANDLE, ' ', 120*28, Cur, &dwLen);
    gotoxy(0,0);
}

/*---------------------------------------------------------*/
void view_departments() {
    EXEC SQL BEGIN DECLARE SECTION;
    varchar dept_id[10];       // 진료과 ID
    varchar dept_name[100];    // 진료과 이름
    EXEC SQL END DECLARE SECTION;

    int x = 10, y = 6;         // 출력 위치 좌표
    int count = 0;             // 출력한 항목 수

    // 화면 초기화 및 출력
    clrscr();
    print_screen("scr_view_departments.txt");

    // SQL SELECT 실행
    EXEC SQL DECLARE dept_cursor CURSOR FOR
        SELECT dept_id, dept_name FROM department;

    EXEC SQL OPEN dept_cursor;

    // 데이터 출력
    printf("\n진료과 목록:\n");
    printf("----------------------------------------\n");
    printf("| ID       | 이름                      |\n");
    printf("----------------------------------------\n");

    while (1) {
        EXEC SQL FETCH dept_cursor INTO :dept_id, :dept_name;

        // 데이터가 더 이상 없으면 종료
        if (sqlca.sqlcode == 1403) { // No data found
            break;
        }

        // SQL 오류 처리
        if (sqlca.sqlcode < 0) {
            printf("\n데이터를 가져오는 중 오류가 발생했습니다. 아무 키나 입력하세요.\n");
            getch();
            EXEC SQL CLOSE dept_cursor;
            return;
        }

        // NULL 종료 처리
        dept_id.arr[dept_id.len] = '\0';
        dept_name.arr[dept_name.len] = '\0';

        // 데이터 출력
        gotoxy(x, y);
        printf("| %-8s | %-25s |\n", dept_id.arr, dept_name.arr);
        y++;
        count++;

        // 한 화면에 10개씩 출력 후 대기
        if (count % 10 == 0) {
            printf("\n----------------------------------------\n");
            printf("추가 목록을 보려면 아무 키나 누르세요.\n");
            getch();
            clrscr();
            y = 6; // 출력 위치 초기화
        }
    }

    EXEC SQL CLOSE dept_cursor;

    // 최종 결과 출력
    printf("\n----------------------------------------\n");
    printf("총 진료과 수: %d\n", count);
    printf("목록을 보려면 아무 키나 누르세요.\n");
    getch();
}

/*---------------------------------------------------------*/
void reserve_tuple() {
    // SQL 변수 선언 섹션 시작
    EXEC SQL BEGIN DECLARE SECTION;
    varchar v_res_pt[100];      // 환자 이름
    varchar v_res_birth[20];    // 환자 생년월일 (YYYY-MM-DD 형식)
    varchar v_res_phone[20];    // 전화번호
    varchar v_res_gender[10];   // 성별 (남/여)
    varchar v_res_dept[100];    // 진료과
    varchar v_res_date[100];    // 예약 날짜 (YYYY-MM-DD HH24:MI 형식)
    EXEC SQL END DECLARE SECTION;

    char confirm;               // 예약 확인 여부를 받을 변수
    int x, y;                   // 화면 출력 좌표 변수

    // 화면 초기화 및 예약 입력 화면 출력
    clrscr();
    print_screen("scr_add_reservation.txt");

    // 예약 정보 입력 받기
    x = 39;
    y = 6;
    gotoxy(x, y);               // 입력 위치 설정
    printf("환자 이름: ");
    fgets(v_res_pt.arr, sizeof(v_res_pt.arr), stdin); // 환자 이름 입력
    v_res_pt.len = strlen(v_res_pt.arr) - 1;         // 개행 문자 제거

    printf("\n                            생년월일 (YYYY-MM-DD): ");
    fgets(v_res_birth.arr, sizeof(v_res_birth.arr), stdin); // 생년월일 입력
    v_res_birth.len = strlen(v_res_birth.arr) - 1;

    printf("\n                            전화번호: ");
    fgets(v_res_phone.arr, sizeof(v_res_phone.arr), stdin); // 전화번호 입력
    v_res_phone.len = strlen(v_res_phone.arr) - 1;

    printf("\n                            성별 (남/여): ");
    fgets(v_res_gender.arr, sizeof(v_res_gender.arr), stdin); // 성별 입력
    v_res_gender.len = strlen(v_res_gender.arr) - 1;

    printf("\n                            진료과: ");
    fgets(v_res_dept.arr, sizeof(v_res_dept.arr), stdin); // 진료과 입력
    v_res_dept.len = strlen(v_res_dept.arr) - 1;

    printf("\n                            예약일 (YYYY-MM-DD HH24:MI): ");
    fgets(v_res_date.arr, sizeof(v_res_date.arr), stdin); // 예약 날짜 입력
    v_res_date.len = strlen(v_res_date.arr) - 1;

    // 입력 내용 확인 및 데이터베이스에 저장
    printf("\n입력하신 정보를 저장하시겠습니까? (y/n): ");
    confirm = getchar();        // 사용자 확인 입력 받기
    while (getchar() != '\n');  // 입력 버퍼 초기화

    if (confirm == 'y' || confirm == 'Y') {
        // SQL INSERT 문 실행
        EXEC SQL INSERT INTO reservation (
            res_pt, res_birth, res_phone, res_gender, res_dept, res_dept_date
        ) VALUES (
            :v_res_pt, :v_res_birth, :v_res_phone, :v_res_gender, :v_res_dept, 
            TO_DATE(:v_res_date, 'YYYY-MM-DD HH24:MI')
        );

        if (sqlca.sqlcode == 0) { // SQL 실행 성공
            printf("\n예약이 성공적으로 추가되었습니다. 아무 키나 입력하세요.\n");
            EXEC SQL COMMIT WORK;  // 트랜잭션 커밋
            getch();               // 사용자 입력 대기
        } else { // SQL 실행 중 오류 발생
            printf("\n예약 추가 중 오류가 발생했습니다. 아무 키나 입력하세요.\n");
            EXEC SQL ROLLBACK WORK;  // 트랜잭션 롤백
            getch();                // 사용자 입력 대기
        }
    } else { // 사용자가 저장을 취소한 경우
        printf("\n예약 추가가 취소되었습니다. 아무 키나 입력하세요.\n");
        getch();  // 사용자 입력 대기
    }
}
